/* This is the prototype for ASSIGNMENT 1 FOR COMP20007
   Student Number: 828472
   Modules List, Queues and Stack make use of code provided by Matt Farrugia
   */

#include <stdio.h>
#include "traverse.h"
#include "queue.h"
#include "stack.h"


int maxn = graph->maxn;

//==========================PART 1=============================================

void print_dfs(Graph* graph, int source_id) {
	/*
	Create a stack
	Create a new choice point
	Push the choice point onto the stack
	while (not found and stack is not empty)
		Pop the stack
		Find all possible choices after the last one tried
		Push these choices onto the stack
	Return
	*/
	
	//DECLARATION AND INITIALISATION
	int vlist[maxn], i;
	Stack *tmp_stk;
	
	
	//creating a temporary stack
	tmp_stk = new_stack();
	
	//creating list of visited places, marking them to unvisited as default
	for(i=0;i<maxn;i++){
		vlist[i]= 0;
	}
	
	
	while(((stack_is_empty(tmp_stk))== False)
	
	
	printf("PRINT OUTPUT LAST\n");
}

//helper function to check if vertice has been visited or not
int
visited(int vlist[maxn], int i){
	
	if(vlist[i]==1){
		return 1;
	}
	//if vertice is unvisited, mark it as visited and go to it
	else{
		vlist[i]= 1;
	}

	//if vertice has not been visited
	return 0;
}

//recursive vertice exploring function
int
explorer(Graph* graph, int current, int vlist[]){
	
	vlist[current] = 1;
	for()
	
	
}



//==========================PART 2=============================================

void print_bfs(Graph* graph, int source_id) {
	printf("not yet implemented: put code for part 2 here\n");
}

void detailed_path(Graph* graph, int source_id, int destination_id) {
	printf("not yet implemented: put code for part 3 here\n");
}

void all_paths(Graph* graph, int source_id, int destination_id) {
	printf("not yet implemented: put code for part 4 here\n");
}

void shortest_path(Graph* graph, int source_id, int destination_id) {
	printf("not yet implemented: put code for part 5 here\n");
}
